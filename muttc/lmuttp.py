# i was bored of writing a proper compiler so
# here is a "temporary" one until i write
# a real one.
#
# edit: i'll probably end up keeping this
# so get used to this un-modular,
# poorly commented, ugly lump of code.
# plus it's full of cryptically named vars.
# enjoy.

import sys
import mutth

f_in = sys.argv[1]
f_out = sys.argv[0]

with open(f_in,"r") as r_file:
    m_src = r_file.read()

# create some room to close any open parentheses
m_src += "\n"

# last line indent level
lind_lvl = 0
# are we currently in a string
in_str = False
# string start line
str_start = 0
# these are both the position in the file
# FIXME: line number is calculated incorrectly:
# if you skip over \n ex: while examining an
# if statement
#
# solution: add a get_line function
cursor = 0

simple_st = ["if","elif","while","switch"]

# this block contains reserved words that get offloaded to the c compiler
mutt_mcr = """/* auto generated by mutt */
#define elif else if
#define not !
#define and &&
#define or ||
#define true 1
#define false 0
#define bool _Bool
#define pass ((void)0)
#define object typedef struct
/* src begins here */

"""

# TODO: eliminate short/abbreviated names in this and mutth
# TODO: add muttcln to clean up files with:
#  - comment remover
#  - space to indent detector and converter
#  - namespace handler (MAYBE)
# TODO: header generation and import
# TODO: structs, enums, and auto typedefs
# TODO: @flags
# TODO: get_line
# TODO: add function closing
# TODO: fix switch fallthrough
# TODO: auto include generated header
# TODO: standardize cursor start and finish in mutth functions

# begin compilation
while(cursor<len(m_src)):
    # this is string thing
    chara=m_src[cursor]
    if chara == "\"" and not m_src[cursor-1] == "\\":
        in_str = not in_str
        # FIXME: set line number
        str_start = 0
    elif chara == "\t" and m_src[cursor-1] == "\n":
        # TODO: handle indentation and semicolons
        pass
    elif not in_str:
        start,finish,word = mutth.get_next_word(m_src,cursor)
        if word in simple_st:
            cursor = finish
            m_src,_,lind_lvl,ind_delta = mutth.check_indents_add_brackets(m_src,start,lind_lvl)
            start += ind_delta
            finish += ind_delta
            cursor += ind_delta
            m_src = mutth.insert_at(m_src,"(",cursor)
            # TODO: handle possible errors
            close_if = mutth.get_statement(m_src,cursor)
            m_src = mutth.set_at(m_src,")",close_if)
            m_src = mutth.insert_at(m_src,"{",close_if+1)
            cursor = close_if+1
        elif word == "else":
            cursor = finish
            m_src,_,lind_lvl,ind_delta = mutth.check_indents_add_brackets(m_src,start,lind_lvl)
            start += ind_delta
            finish += ind_delta
            cursor += ind_delta
            # TODO: handle possible errors
            close_if = mutth.get_statement(m_src,cursor)
            m_src = mutth.chop_at(m_src,close_if,close_if+1)
            # since we cut a letter out the cursor is now ahead by one 
            m_src = mutth.insert_at(m_src,"{",close_if)
        elif word in ["case","default"]:
            cursor = finish
            m_src,_,lind_lvl,ind_delta = mutth.check_indents_add_brackets(m_src,start,lind_lvl)
            start += ind_delta
            finish += ind_delta
            cursor += ind_delta
            # TODO: handle possible errors
            close_if = mutth.get_statement(m_src,cursor)
            # cases have their own scope
            # TODO: prevent fallthrough by adding break
            m_src = mutth.insert_at(m_src,"{",close_if+1)
            cursor = close_if+1
        elif word in ["var", "const"]:
            # TODO: add comments in this area
            m_src,cursor,lind_lvl,ind_delta = mutth.check_indents_add_brackets(m_src,start,lind_lvl)
            start = cursor
            finish += ind_delta
            const = "const" if word.replace(" ","").replace("\t","") == "const" else ""
            def_p = mutth.get_var_declaration_end(m_src,finish)
            name_start,name_end,name = mutth.get_next_word(m_src,finish)
            var = m_src[name_start:def_p]
            var = var.split(":")
            if not len(var) == 2:
                print("you forgot to give your variable a type :(")
                sys.exit(-1)
            def_start, def_end, vdef = mutth.get_var_definition(m_src, cursor)
            mod_src = mutth.chop_at(m_src,cursor,def_end)
            mod_src = mutth.insert_at(mod_src, f"{const} {var[1]} {name} {vdef} \n",cursor)
            step = len(mod_src)-len(m_src)
            m_src = mod_src
            cursor = mutth.get_semicolon(m_src,cursor)+1
            m_src = mutth.insert_at(m_src,";",cursor-1)
        elif word == "func":
            m_src,cursor,lind_lvl,ind_delta = mutth.check_indents_add_brackets(m_src,start,lind_lvl)
            start = cursor
            finish += ind_delta
            m_src = mutth.chop_at(m_src,start,finish)
            name_start,name_end,name = mutth.get_next_word(m_src,cursor)
            # get the section of the function in parentheses
            p_start,p_end,inner_str = mutth.get_function_arguments_contents(m_src,cursor)
            c_args = mutth.get_c_args(inner_str)
            # get the return type
            # FIXME: currently only gets the next word so
            # functions cant return something like: struct my_struct *
            rtrn_s,rtrn_e,return_type = mutth.get_next_word(m_src,p_end)
            # get end of function
            f_end = mutth.get_function_end(m_src,rtrn_s)
            # create the code
            o_sz = len(m_src)
            m_src = mutth.chop_at(m_src,p_end+1,f_end)
            m_src = mutth.insert_at(m_src,"{",p_end+1)
            m_src = mutth.chop_at(m_src,p_start,p_end+1)
            m_src = mutth.insert_at(m_src,f"({c_args})",p_start)
            m_src = mutth.insert_at(m_src,return_type,cursor)
            # move our cursor to the next section
            delta_sz = len(m_src)-o_sz
            cursor = f_end+delta_sz
            if(not mutth.block_line(m_src,cursor)):
                print("please do not place code on the same line as the function")
                print("sic em' mutt!")
                # refuse to compile
                sys.exit(-1)
        elif word == "object":
            m_src,start,lind_lvl,ind_delta = mutth.check_indents_add_brackets(m_src,start,lind_lvl)
            finish += ind_delta
            cursor = finish
            # get the end, indents, and the object name
            indents = mutth.get_indent_count(m_src,cursor)
            _,object_name_end,object_name = mutth.get_next_word(m_src,cursor)
            object_def_end = mutth.get_statement(m_src,object_name_end)
            # add bracket and delete name
            m_src = mutth.insert_at(m_src,"{",object_def_end+1)
            m_src = mutth.chop_at(m_src,cursor,object_def_end+1)
            # find object end and cleanup struct indents
            p_cursor = mutth.get_line_end(m_src,cursor)+1
            ln_indents = indents
            got_line = False
            while(p_cursor<len(m_src)): 
                if not got_line:
                    ln_start,_,_ = mutth.get_next_word(m_src,p_cursor)
                    ln_indents = mutth.get_indent_count(m_src,ln_start)
                    ln_indents_delta = ln_indents
                    got_line = True
                if ln_indents <= indents and m_src[p_cursor] != "\n" and m_src[p_cursor+1] != "\t":
                    print([m_src[p_cursor-3]+m_src[p_cursor-2]+m_src[p_cursor-1]+m_src[p_cursor]])
                    print(indents)
                    print(ln_indents)
                    break
                elif ln_indents_delta > indents and m_src[p_cursor] == "\t":
                    ln_indents_delta -= 1
                    m_src = mutth.chop_at(m_src,p_cursor,p_cursor+1)
                else:
                    if m_src[p_cursor] == "\n":
                        got_line = False
                    p_cursor += 1
            # add name to end
            m_src = mutth.insert_at(m_src,"\n"+("\t"*indents)+"}"+object_name+"\n",p_cursor-1)
        else:
            m_src,cursor,lind_lvl,ind_delta = mutth.check_indents_add_brackets(m_src,start,lind_lvl)
            # last line is always len of 0
            if (len(word) == 0):
                break
            cursor = mutth.get_semicolon(m_src,cursor)+1
            m_src = mutth.insert_at(m_src,";",cursor-1)
    cursor += 1

# add the headers and remove returns
#m_src = m_src.replace("\n","")
m_src = mutt_mcr+m_src
print(m_src)

if in_str:
    print(f"unclosed string starting on line: {str_start}")

# i was bored of writing a proper compiler so
# here is a "temporary" one until i write
# a real one.
#
# edit: i'll probably end up keeping this
# so get used to this un-modular,
# poorly commented, ugly lump of code.
# plus it's full of cryptically named vars.
# enjoy.

import sys

f_in = sys.argv[1]
f_out = sys.argv[0]

with open(f_in,"r") as r_file:
    m_src = r_file.read()

# last line indent level
lind_lvl = 0
# are we currently in a string
in_str = False
# string start pos
str_start = 0
# these are both the position in the file
# FIXME: line number is calculated incorrectly:
# if you skip over \n ex: while examining an
# if statement
#
# solution: add a get_line function
cursor = 0
ln_num = 0

simple_st = ["if","elif","while","switch"]

# this block contains reserved words
mutt_mcr = """/* auto generated by mutt */
#define elif else if
#define not !
#define and &&
#define or ||
#define true 1
#define false 0
#define bool _Bool
/* src begins here */

"""

def is_notspace(string):
    return (string.isalpha() or string in ["_","[","]","*"] or string.isdigit()) and not string.isspace() # isspace might be redundant

def get_next_wrd(src,cursor):
    cursor_p = cursor
    word = ""
    src_sz = len(src)
    word_s = cursor
    word_f = cursor
    while(cursor_p<src_sz and not is_notspace(src[cursor_p])):
        cursor_p +=1
    word_s = cursor_p
    while(cursor_p<src_sz and is_notspace(src[cursor_p])):
        word += src[cursor_p]
        cursor_p +=1
    word_f = cursor_p
    return (word_s,word_f,word)

def insert_at(string, thing, place):
    return string[:place] + thing + string[place:]

def set_at(string, thing, place):
    new_str = list(string) 
    new_str[place] = thing
    return "".join(new_str)

def chop_at(string, start, end):
    return string[:start] + string[start+abs(end-start):]

def get_stmnt(src,cursor):
    p_cursor = cursor
    in_str = False
    no_colon = True
    while(p_cursor<len(src)): 
        chara = src[p_cursor] 
        if chara == "\"" and not m_src[cursor-1] == "\\":
            in_str = not in_str
            str_start = p_cursor
        elif chara == ":" and not in_str:
            no_colon = False
            break
        p_cursor+=1
    if no_colon or in_str:
        #TODO: add error and stop compiler
        print("if statement unfinished")
    return p_cursor

def block_line(src,cursor):
    p_cursor = cursor
    while(p_cursor<len(src)): 
        char = src[p_cursor]
        if(char == "\n"):
            return True
        elif(is_notspace(char)):
            return False
        p_cursor += 1
    # TODO: handle error
    print("expected line after statement or function")
    return False

def get_var_dec_end(src,cursor):
    p_cursor = cursor
    while(p_cursor<len(src)): 
        char = src[p_cursor]
        if(char in ["\n", "="]):
            return p_cursor
        p_cursor += 1
    return p_cursor

def is_var_defed(src,cursor):
    p_cursor = cursor
    while(p_cursor<len(src)): 
        char = src[p_cursor]
        if char == "\n":
            return False
        elif char == "=":
            return True
        p_cursor += 1
    return True

def get_line_end(src,cursor):
    p_cursor = cursor
    while(p_cursor<len(src)): 
        char = src[p_cursor]
        if(char == "\n"):
            return p_cursor
        p_cursor += 1
    return p_cursor

def get_var_def(src,cursor):
    if not is_var_defed(src,cursor):
        return (cursor,get_line_end(src,cursor),"")
    p_cursor = cursor
    p_layers = [0,0,0]
    p_opens = ["[","{","("]
    p_close = ["]","}",")"]
    in_string = False
    found_def = False
    # find the =
    while(p_cursor<len(src)): 
        char = src[p_cursor]
        if(char == "="):
            found_def = True
            break
        p_cursor += 1
    #TODO: error
    if not found_def:
        print("something is weird about your definition")
        return
    d_start = p_cursor
    # now get the insides
    insides = ""
    while(p_cursor<len(src)): 
        char = src[p_cursor]
        insides += char
        if(char == "\"" and not src[p_cursor-1] == "\\"):
            in_string = not in_string
        elif(char in p_opens):
            p_layers[p_opens.index(char)] += 1
        elif(char in p_close):
            p_layers[p_close.index(char)] -= 1
        elif(char == "\n" and (p_layers[0]+p_layers[1]+p_layers[2])==0 and not in_string):
            return (d_start,p_cursor,insides)
        p_cursor += 1
    # TODO: yeah do something with this error
    print("variable defined wrong")
    raise Exception("something went wrong again")

def get_semicolon(src,cursor):
    p_cursor = cursor
    p_layers = [0,0,0]
    p_opens = ["[","{","("]
    p_close = ["]","}",")"]
    in_string = False
    d_start = p_cursor
    # now get the insides
    insides = ""
    while(p_cursor<len(src)): 
        char = src[p_cursor]
        if(char == "\"" and not src[p_cursor-1] == "\\"):
            in_string = not in_string
        elif(char in p_opens):
            p_layers[p_opens.index(char)] += 1
        elif(char in p_close):
            p_layers[p_close.index(char)] -= 1
        elif(char == "\n" and (p_layers[0]+p_layers[1]+p_layers[2])==0 and not in_string):
            return p_cursor
        p_cursor += 1
    # TODO: yeah do something with this error
    print("variable defined wrong")
    raise Exception("something went wrong again")

# begin compilation
while(cursor<len(m_src)):
    # this is string thing
    chara=m_src[cursor]
    if chara == "\"" and not m_src[cursor-1] == "\\":
        in_str = not in_str
        str_start = ln_num
    elif chara == "\n":
        ln_num += 1
    elif chara == "\t" and m_src[cursor-1] == "\n":
        # TODO: handle indentation and semicolons
        pass
    elif not in_str:
        start,finish,word = get_next_wrd(m_src,cursor)
        if word in simple_st:
            cursor = finish
            m_src = insert_at(m_src,"(",cursor)
            # TODO: handle possible errors
            close_if = get_stmnt(m_src,cursor)
            m_src = set_at(m_src,")",close_if)
            m_src = insert_at(m_src,"{",close_if+1)
            cursor = close_if+1
        elif word == "else":
            cursor = finish
            # TODO: handle possible errors
            close_if = get_stmnt(m_src,cursor)
            m_src = chop_at(m_src,close_if,close_if+1)
            # since we cut a letter out the cursor is now ahead by one 
            m_src = insert_at(m_src,"{",close_if)
        elif word in ["case","default"]:
            cursor = finish
            # TODO: handle possible errors
            close_if = get_stmnt(m_src,cursor)
            # cases arer their own scope
            # TODO: prevent fallthrough by adding break
            m_src = insert_at(m_src,"{",close_if+1)
            cursor = close_if+1
        elif word in ["var", "const"]:
            cursor = start
            const = "const" if word.replace(" ","").replace("\t","") == "const" else ""
            def_p = get_var_dec_end(m_src,finish)
            name_start,name_end,name = get_next_wrd(m_src,finish)
            var = m_src[name_start:def_p]
            var = var.split(":")
            if not len(var) == 2:
                print("you forgot to give your variable a type :(")
                sys.exit(-1)
            def_start, def_end, vdef = get_var_def(m_src, cursor)
            mod_src = chop_at(m_src,cursor,def_end)
            mod_src = insert_at(mod_src, f"{const} {var[1]} {name} {vdef} \n",cursor)
            step = len(mod_src)-len(m_src)
            m_src = mod_src
            cursor = get_semicolon(m_src,cursor)+1
            m_src = insert_at(m_src,";",cursor-1)
        elif word == "func":
            # TODO: clean some of this up and offload it to another functions
            cursor = start
            m_src = chop_at(m_src,start,finish)
            name_start,name_end,name = get_next_wrd(m_src,cursor)
            # TODO: make this section get_p_contents
            p_cursor = cursor
            no_opening = True
            no_closing = True
            inner_str = ""
            p_start = cursor
            p_end = cursor
            while(p_cursor<len(m_src)):
                  if(m_src[p_cursor] == "("):
                      no_opening = False
                      p_start = p_cursor
                      p_cursor += 1
                      break
                  p_cursor += 1
            if no_opening:
                  #TODO: handle this error properly
                  print("their's something wrong with your func")
                  #return
            while(p_cursor<len(m_src)):
                  if(m_src[p_cursor] == ")"):
                      no_closing = False
                      p_end = p_cursor
                      p_cursor += 1
                      break
                  inner_str += m_src[p_cursor]
                  p_cursor += 1
            if no_closing:
                  #TODO: also handle this error properly
                  print("their's something else wrong with your func")
                  #return
            # end of bad section
            # TODO: make this section get_c_args
            m_args = inner_str.split(",")
            c_args = []
            for arg in m_args:
                  if len(arg) == 0:
                        # their is no args, so we'll just break the for loop.
                        break
                  if "[" in arg:
                        # TODO: do something with this error (again)
                        print("arrays cannot be arguments (try a pointer)")
                        #return
                  arg = arg.split(":")
                  if not len(arg) == 2:
                        # TODO: handle this
                        print("invalid number of types")
                        #return
                  c_args.append(f"{arg[1]} {arg[0]}")
            c_args = str(c_args).replace("[","").replace("]","").replace("'","")
            # end of bad section
            rtrn_s,rtrn_e,return_type = get_next_wrd(m_src,p_end)
            # TODO: move it - get_func_end
            p_cursor = rtrn_s
            no_ending = True
            while(p_cursor<len(m_src)):
                  if(m_src[p_cursor] == ":"):
                      no_ending = False
                      p_cursor += 1
                      break
                  p_cursor += 1
            if no_ending:
                # TODO: you know the drill
                print("function never ended are you missing an \":\"")
                #return
            # end of awful code
            f_end = p_cursor
            o_sz = len(m_src)
            m_src = chop_at(m_src,p_end+1,f_end)
            m_src = insert_at(m_src,"{",p_end+1)
            m_src = chop_at(m_src,p_start,p_end+1)
            m_src = insert_at(m_src,f"({c_args})",p_start)
            m_src = insert_at(m_src,return_type,cursor)
            delta_sz = len(m_src)-o_sz
            cursor = f_end+delta_sz
            if(not block_line(m_src,cursor)):
                print("please do not place code on the same line as the function")
                print("sic em' mutt!")
                # refuse to compile the code
                sys.exit(-1)
        else:
            # FIXME: adds a semicolon to the end of the file. 
            cursor = get_semicolon(m_src,cursor)+1
            m_src = insert_at(m_src,";",cursor-1)
    cursor += 1
#m_src = m_src.replace("\n","")
m_src = mutt_mcr+m_src
print(m_src)

if in_str:
    print(f"unclosed string starting on line: {ln_num}")
